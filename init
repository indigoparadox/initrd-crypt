#!/bin/sh

# = Signal Handlers =

sigusr1() {
   # If USR1 was passed, the passer should also be killing all cryptscripts.
   REMOTE_USR1=1
}

# = Functions =

# Purpose: Find the block device with the requested file and mount it on /boot.
# Parameters: The file to probe block devices for.
probe_block() {
   BLOCK_PROBE_FOUND=0
   # TODO: Detect other kinds of block devices, maybe?
   for BLK_PROBE_ITER in `ls -1 /dev/sd*`; do
      /bin/mount -o ro "$BLK_PROBE_ITER" /mnt/boot 2>/dev/null
      if [ -f "$1" ]; then
         BLOCK_PROBE_FOUND=1

         # This is a weird place to set verbosity but we use it right away.
         # TODO: Get verbose key from the command line.
         #if [ -n "`/bin/grep "V=1" $1`" ]; then
         #   export CFG_VERBOSE=1
         #fi

         if [ 1 = $CFG_VERBOSE ]; then
            echo "Found $1."
         fi
         break
      fi
   done
}

probe_usr() {
   PREMOUNT_USR_NUMBER=`/bin/cat /mnt/root/etc/fstab | \
      /bin/awk '{print $2}' | /bin/grep -n ^/usr$ | \
      /bin/awk 'BEGIN {FS=":"} {print $1}'`
   if [ -n "$PREMOUNT_USR_NUMBER" ]; then
      # The /usr partition is separate, so premount it.
      PREMOUNT_USR_LINE="`/bin/head -n $PREMOUNT_USR_NUMBER \
         /mnt/root/etc/fstab | /bin/tail -n 1`"
      PREMOUNT_USR_DEV="`echo $PREMOUNT_USR_LINE | /bin/awk '{print $1}'`"
      /bin/mount -o ro "$PREMOUNT_USR_DEV" /mnt/root/usr

      if [ 0 -eq $? ] && [ 1 = $CFG_VERBOSE ]; then
         echo "Premount success!"
      elif [ 1 = $CFG_VERBOSE ]; then
         echo "Premount failed..."
      fi
   fi
}

action_crypt() {
   # Remember some things.
   export CFG_VERBOSE=0
   REMOTE_USR1=0

   #if [ $BLOCK_PROBE_FOUND -ne 1 ]; then
      # No config file was found, so quit.
      #action_console
   #fi

   # Try to start any RAID arrays.
   for RAID_ITER in `/bin/grep "^M_MD" "/etc/cryscry.cfg"`; do
      RAID_MD_ITER="`echo $RAID_ITER | /bin/awk -F'=' '{print $2}'`"
      RAID_DEVS_ITER="`echo $RAID_ITER | /bin/awk -F'=' '{print $3}'`"
   
      /sbin/mdadm --assemble $RAID_MD_ITER `echo $RAID_DEVS_ITER | tr "," " "`
   done

   # Try to start network listener.
   if [ -f "/etc/cryscry.cfg" ] && \
      [ -n "`/bin/grep "^SSH" "/etc/cryscry.cfg" | \
         /bin/awk -F'=' '{print $2}'`" ] && \
      [ -n "`/bin/grep "^IP4" "/etc/cryscry.cfg" | \
         /bin/awk -F'=' '{print $2}'`" ] && \
      [ -n "`/bin/grep "^IP4" "/etc/cryscry.cfg" | \
         /bin/awk -F'=' '{print $3}'`" ]
   then
      # Listen for the queue to skip local decryption.
      trap 'sigusr1' USR1

      # Load the configuration.
      CFG_NET_IF="`/bin/grep "^IP4" "/etc/cryscry.cfg" | \
         /bin/awk -F'=' '{print $2}'`"
      CFG_NET_IP4="`/bin/grep "^IP4" "/etc/cryscry.cfg" | \
         /bin/awk -F'=' '{print $3}'`"
      CFG_SSH_PORT="`/bin/grep "^SSH" "/etc/cryscry.cfg" | \
         /bin/awk -F'=' '{print $2}'`"
      CFG_DDNS_USER="`/bin/grep "^DDNS_USER" "/etc/cryscry.cfg" | \
         /bin/awk -F'=' '{print $2}'`"
      CFG_DDNS_PASS="`/bin/grep "^DDNS_PASS" "/etc/cryscry.cfg" | \
         /bin/awk -F'=' '{print $2}'`"
      CFG_DDNS_DOMAIN="`/bin/grep "^DDNS_DOMAIN" "/etc/cryscry.cfg" | \
         /bin/awk -F'=' '{print $2}'`"

      # Start the network interface.
      /sbin/ifconfig "$CFG_NET_IF" up
      if [ "$CFG_NET_IP4" = "DHCP" ]; then
         /bin/udhcpc -t 5 -q -p /var/run/udhcpc.pid -s /bin/simple.script \
            >/dev/null 2>&1 &
      else
         /sbin/ifconfig "$CFG_NET_IF" "$CFG_NET_IP4"
      fi
      if [ 0 != $? ] && [ 1 = $CFG_VERBOSE ]; then
         echo "Started network on $CFG_NET_IF with address $CFG_NET_IP4."
      fi

      # Start the SSH listener.
      /sbin/dropbear -s -j -k -p $CFG_SSH_PORT >/dev/null 2>&1
      if [ 0 != $? ] && [ 1 = $CFG_VERBOSE ]; then
         echo "Started remote decryption service."
      fi

      # Signal dynamic DNS.
      # TODO: Test me!
      if [ -n "$CFG_DDNS_USER" ] && \
         [ -n "$CFG_DDNS_PASS" ] && \
         [ -n "$CFG_DDNS_DOMAIN" ]
      then
         /bin/wget https://$CFG_DDNS_USER:$CFG_DDNS_PASS@www.dnsdynamic.org/api/?hostname=$CFG_DDNS_DOMAIN
         # > /dev/null 2>&1
      fi
   fi

   # Get the user password.
   /sbin/cryptscript

   if [ 0 != $? ] && [ $REMOTE_USR1 = 0 ]; then
      # Failure to mount!
      #/bin/busybox --install && /bin/sh
      /sbin/sysmounts -u
      /sbin/reboot -f
   fi

   if [ "$CFG_NET_IP4" = "DHCP" ]; then
      # Kill the DHCP daemon.
      # TODO: Test me!
      kill `cat /var/run/udhcpc.pid`
   fi

   # Try to premount /usr, because of the new udev.
   probe_usr
}

action_loop() {
   probe_block /mnt/boot/liveusb

   mount -o loop -t squashfs \
      /mnt/boot/liveboot/recovery/usbgentoo/usbgentoo.fs \
      /mnt/root || \
   action_console
}

action_console() {
   echo "Do your best!"
   /bin/busybox --install && /bin/sh
}

# = Main Procedure =

# Get ready to get the system ready.
/sbin/sysmounts -m

if [ -x "/sbin/fbsplashd" ]; then
   # TODO: Provide theme selection.
   /sbin/fbsplashd --theme=natural_gentoo
fi

# Try to probe some modules.
if [ -f /etc/modules.list ] && [ -n "`cat /etc/modules.list`" ]; then
   for MODULE_PROBE_ITER in `cat /etc/modules.list`; do
      /sbin/modprobe -q ${MODULE_PROBE_ITER}
   done
fi

# Should we be quiet?
if [ -z "`/bin/grep quiet /proc/cmdline`" ]; then
   CFG_VERBOSE=0
else
   CFG_VERBOSE=1
fi

# Wait for USB devices.
sleep 4

# Figure out our intended action.
for CMDLINE_ITER in `cat /proc/cmdline`; do
   CMD_KEY_ITER=`echo $CMDLINE_ITER | awk 'BEGIN { FS="=" } {print $1}'`
   CMD_VAL_ITER=`echo $CMDLINE_ITER | awk 'BEGIN { FS="=" } {print $2}'`
   if [ "initdo" = "$CMD_KEY_ITER" ]; then
      # Execute the specified initrd action.
      case $CMD_VAL_ITER in
         "crypt")
            action_crypt
            ;;

         "loop")
            action_loop
            ;;

         *)
            action_console
            ;;
      esac
      break
   fi
done

if [ -x "/sbin/fbsplashd" ]; then
#   /sbin/fbsplashd --daemon --theme=natural_gentoo
   echo "set mode silent" > /lib/splash/cache/.splash
#   echo "set mode silent" > /mnt/root/lib/splash/cache/.splash
fi

# Clean up and prepare for the real thing.
#/sbin/splash_util --mode=s -c setmode
/sbin/sysmounts -u

exec switch_root /mnt/root /sbin/init

